<doc xmlns="http://www.ibm.com/iis/flow-doc">
 <!--  ************************  -->
 <!--  ABOUT THIS DOCUMENT  -->
 <!--
 This is a documented sample ASSET import document for bundle-defined assets.
-->
 <!--
 It will typically be generated by code that periodically extracts a tool's metadata and pushes it to IGC, using the IGC REST API.
-->
 <!--
 The example is for importing a project and a job within the project, conforming to the sample bundle DataMass.
-->
 <!--
 NOTE: Only assets of bundle-defined classes can be imported using the bundle asset import service
-->
 <!--  ************************  -->
 <!--
 GENERAL IMPORT/MERGE RULES

    A. Attribute values are always replaced on re-import (even for multi-valued attributes).
    B. Values of attributes that are not mentioned are left unchanged.
    C. Listing an attribute without a value will null it out. Example:
            <attribute name="$phase" value=""/>
    	Note: Empty strings cannot be stored, which is consistent with the rest of IGC and the XMeta repository.
    D. All governance assignments are preserved (Terms, Collections, Labels, Stewards, Business names, ...).
       NOTE: These cannot be set or changed using the bundle asset import, rather only from IGC GUI or via the common IGC REST API.
    E. Regarding previously imported containment member assets that are not mentioned in the import document, see #7 below.
-->
 <!--  ************************  -->
<assets>
 <!--  	One or more assets:  -->
 <!--  ************************  -->
 <!--
    1. XML attributes that describe an asset:
			class: Asset class REST name, in the form '$' <bundleId> '-' <class-localId>
				   Note: The $ sign prevents name clashes between core classes and bundle-defined classes. The bundleId prevents name clashes between classes from different bundles.
			repr:  Representation. Must be the same as the value for the required attribute 'name', see #2.
			ID:    Merely *doc-internally* unique asset id (XML ID/IDREF mechanism). No need to be *globally* unique. No need to be the same in *other* import docs.
				   Must start with a letter and continue with letters or digits. Used for relating between assets within a given import document.
			Example:
-->
<asset class="$DataMass-Project" repr="TestProj" ID="a1">
 <!--  		Asset attributes and references  -->
 <!--
 		At the very least, must provide the core attribute 'name' and the reference to container, if any. They define the 'logical identity'.
-->
 <!--
 		In addition, can set the core attributes short_description / long_description and any bundle-defined attributes.
-->
 <!--
 		2. Required: 'name' attribute.
				value: This asset's name, which is always assumed to be part of logical asset identity.
-->
<attribute name="name" value="TestProj"/>
 <!--  		3. Optionally, short_description:  -->
<attribute name="short_description" value="Up to 255 chars."/>
 <!--  		4. Optionally, long_description:  -->
<attribute name="long_description" value="Can be a long text. will be stored in igc as sql clob. igc query conditions on long_description are case-sensitive."/>
 <!--
 		5. Optionally, any attributes defined for this bundle class.
-->
 <!--
    	XML attributes that describe an asset's attribute value(s):
				name:  REST name of the attribute in the bundle definition, in the form: '$' <attribute-localId>.
						Note: The $ sign prevents name clashes between inherited core attributes and bundle-defined attributes.
				value: String representation of the value, according to the attribute type.
						* For dates, use epoch-based long int values, to the milliseconds (AS IN java.util.Date)..
				Example:
-->
<attribute name="$phase" value="DEV"/>
 <!--  		Optionally, more bundle-defined attributes...  -->
 <!--
 		If an asset's class defines a container relationship, then that asset must have a reference to its container asset.
-->
 <!--
 		This asset's class does not have a container class. See next asset for an example of a container reference.
-->
</asset>
 <!--  ************************  -->
 <!--  	Example with a container reference:  -->
 <!--
 	For XML attributes that describe an asset, see comment #1 above.
-->
<asset class="$DataMass-Job" repr="EmailJoiner" ID="a2">
 <!--
 		Required: 'name' attribute, part of logical asset identity, see #2.
-->
<attribute name="name" value="EmailJoiner"/>
 <!--
 		6. If an asset's class defines a container relationship, then:
-->
 <!--
 			a. List the container asset in the same import doc (preferably above, by convention).
-->
 <!--  			b. State the reference to the container asset.   -->
 <!--
 		XML Attributes that describe a reference to the container asset:
				name:     REST name of the container reference, in the form: '$' <container-class-localId>
				assetIDs: Exactly one ID of the asset that contains this asset, within this doc.
			Example:
			This asset's class defines a containment relationship: containerClassRefs="Project".
			Therefore, this asset must point to its container asset:
-->
<reference name="$Project" assetIDs="a1"/>
</asset>
 <!--  ************************  -->
 <!--
 Optionally, more assets, such as: internal job structures (stages, fields, operators, variables, ...) ...
-->
 <!--
 	The following inner structure comes to complete the sample in preparation for the FLOW import.
-->
 <!--
 In terms of asset import mechanisms, it's just more of the same. Skip to #7.
-->
<asset class="$DataMass-Stage_File" repr="NameExtractorFromDB" ID="a3">
<attribute name="name" value="NameExtractorFromDB"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="fullname" ID="a4">
<attribute name="name" value="fullname"/>
<reference name="$Stage" assetIDs="a3"/>
</asset>
<asset class="$DataMass-Stage_File" repr="EmailExtractorFromDB" ID="a5">
<attribute name="name" value="EmailExtractorFromDB"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="email" ID="a6">
<attribute name="name" value="email"/>
<reference name="$Stage" assetIDs="a5"/>
</asset>
<asset class="$DataMass-Stage_File" repr="Joiner" ID="a7">
<attribute name="name" value="Joiner"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="niceEmail" ID="a8">
<attribute name="name" value="niceEmail"/>
<reference name="$Stage" assetIDs="a7"/>
</asset>
<asset class="$DataMass-Stage_File" repr="WriterToFile" ID="a9">
<attribute name="name" value="WriterToFile"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="niceEmail" ID="a10">
<attribute name="name" value="niceEmail"/>
<reference name="$Stage" assetIDs="a9"/>
</asset>
</assets>
 <!--  ************************  -->
 <!--  7. Import merge rule directive.  -->
 <!--  BACKGROUND  -->
 <!--
 A. With some assets, importing a new version should *completely* replace the inner structure of a previously imported asset. Examples: Job, Procedure.
-->
 <!--
 	Thus, for such assets, the import doc will contain the complete inner structure: all the assets that it contains. Examples: Stage, Operator, Variable, Field.
-->
 <!--
 	Let's call such assets, therefore, 'Complete Assets'.
-->
 <!--
 	==> Therefore, on re-import of 'complete assets', the import service needs to delete any previously imported inner assets that are not listed in the import document.
-->
 <!--
 	    In short: On re-import, *replace* the inner structure of 'complete assets'.
-->
 <!--
 B. Other assets are used for merely grouping / scoping / organizing other assets. Examples: Project, Workspace, Package, Folder.
-->
 <!--
 	For such assets, the import doc may contain only *some* of the contained assets. The absence of a member asset does NOT mean it should be deleted from the repository.
-->
 <!--
 	Let's call such assets, therefore, 'Partial Assets'.
-->
 <!--
 	==> Therefore, on re-import of 'partial assets', the import service should NOT delete previously imported inner assets, even if they are not present in the import document.
-->
 <!--
 		In short: On re-import, add/merge the inner structure of 'partial assets'.
-->
 <!--  XML attributes of the import action directive:  -->
 <!--
   	partialAssetIDs:  IDs of all 'partial assets' listed above. These assets and their member assets will be merged or added.
-->
 <!--
   					  If you use one import document per project-like asset, then partialAssetIDs will contain exactly one ID.
-->
 <!--
   	completeAssetIDs: IDs of all 'complete assets' listed above. These assets will be merged or added.
-->
 <!--
   					  Their member assets will replace any previously imported structures. Pre-existing member assets not listed in this document will be deleted.
-->
 <!--
   					  If you use one import document per job-like asset, then completeAssetIDs will contain exactly one ID.
-->
 <!--  	Example:  -->
 <!--
 		(Note how IDs 'a3' and on are not listed below at all, since they are member assets of 'a2', which is already listed in completeAssetIDs.)
-->
<importAction partialAssetIDs="a1" completeAssetIDs="a2"/>
</doc>
