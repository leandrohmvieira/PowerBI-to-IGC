<doc xmlns="http://www.ibm.com/iis/flow-doc">
 <!--  ************************  -->
 <!--  I. ABOUT THIS DOCUMENT  -->
 <!--  This is a documented sample data FLOW document.   -->
 <!--
 It will typically be generated by code that periodically extracts a tool's metadata and pushes it to IGC, using the IGC REST API.
-->
 <!--
 The example is for expressing data flow through a sample bundle DataMass job.
-->
 <!--
 NOTE: This type of document can express data flows between IGC core type assets as well as assets of bundle-defined types.
-->
 <!--  ************************  -->
 <!--
 II. GENERAL STRUCTURE

    A. List of assets.
    B. List of flows, mapping source assets to target assets.
    C. Rule: All assets involved as sources or as targets in flows must be listed, and also their container assets, recursively.
-->
 <!--  ************************  -->
 <!--
 III. RECOMMENDATIONS FOR REPRESENTING DATA FLOW

    A. Describe data flow on the finest-grained level possible, on the level of database columns / data file attributes / fields.
       If you don't have access to this level of metadata, then aim for table-level flows.
    B. Try not to mix levels, if possible. Map columns to fields and tables to stages. Not, for example, fields to databases.
-->
 <!--  ************************  -->
 <!--

 	IV. THE EXAMPLE AND WHAT IT ILLUSTRATES

 	This sample flow document describes the following, simple data flow:

 		                            __________________________________________________________________________________
 		                           |  Job "EmailJoiner", in Project "TestProj"                                        |
 		                           |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                                        |
 		                           |                                                                                  |
		database_table "CLIENTS" ====> Stage "NameExtractorFromDB"  ==                                                |
		                           |                                   |==> Stage "Joiner" ==> Stage "WriterToFile" ====> data_file "NiceEmails.txt"
		database_table "EMAILS"  ====> Stage "EmailExtractorFromDB" ==                                                |
  		                           |                                                                                  |
 		                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 	Let's say the job "EmailJoiner" takes names (Boris Melamed) from one DB table, raw email addresses (borism@il.ibm.com) from another table,
 	and is writing "nice" email addresses ("Boris Melamed <borism@il.ibm.com>") to a file.

 	Using this sample, this document explains:

  	A. How to uniquely describe the assets of bundle-defined classes.

 	B. How to uniquely describe the most common shared data sources: DB tables and data files.
 	   DBs can be identified in one of two ways:
 		a. By their canonical identity: host name - db name.
 		b. By a data connection: host name - connection string. This requires a subsequent one-time data connection mapping in IGC Admin GUI.
 	  In many cases, tools are using data connections and do not have access to the canonical DB identity or the data connection mapping. In those cases, use (b).

 	C. How to describe flows...
 		a. A flow unit is the asset whose deletion should delete all dependent flows. Examples: Job, Job run, Procedure.
 		b. Flows can be grouped:
 			i. Inner flows of a flow unit, mostly of type 'SYSTEM'.
 			ii. Access of data sources, where the type can be 'DESIGN', 'OPERATIONAL', ... (see enum FlowTypeID, in flow_v1_0.xsd)
 			iii. When asset structures can be re-used in multiple flow units, the reuseType must also be provided ('ENTRY', 'INNER', 'EXIT').
 				 Note: Some tool integrations choose not to reuse asset structures and create them separately for each run.

-->
<assets>
 <!--  	One or more assets:  -->
 <!--  ************************  -->
 <!--
    1. XML attributes that describe an asset of a bundle-defined class:
			class: Asset class REST name, in the form '$' <bundleId> '-' <class-localId>
				   Note: The $ sign prevents name clashes between core classes and bundle-defined classes. The bundleId prevents name clashes between classes from different bundles.
			repr:  Representation. Must be the same as the value for the required attribute 'name', see #2.
			scopeUnit: Must be 'true' for "minimal" assets that get deleted explicitly, such as Job, Procedure. Default is 'false', can be omitted for other assets.
			ID:    Merely *doc-internally* unique asset id (XML ID/IDREF mechanism). No need to be *globally* unique. No need to be the same in *other* import docs.
				   Must start with a letter and continue with letters or digits. Used for relating between assets within a given import document.
			Example:
-->
<asset class="$DataMass-Project" repr="TestProj" ID="a1">
 <!--  		Asset attributes and references  -->
 <!--
 		For assets of bundle-defined classes, must provide the core attribute 'name' and the reference to container, if any. They define the 'logical identity'.
-->
 <!--
 		2. Required: 'name' attribute.
				value: This asset's name, which is always assumed to be part of logical asset identity.
-->
<attribute name="name" value="TestProj"/>
 <!--
 		If an asset's class defines a container relationship, then that asset must have a reference to its container asset.
-->
 <!--
 		This asset's class does not have a container class. See next asset for an example of a container reference.
-->
</asset>
 <!--  ************************  -->
 <!--
 	Example with a container reference and scopeUnit="true":
-->
 <!--
 	For XML attributes that describe an asset, see comment #1 above.
-->
<asset class="$DataMass-Job" repr="EmailJoiner" scopeUnit="true" ID="a2">
 <!--
 		Required: 'name' attribute, part of logical asset identity, see #2.
-->
<attribute name="name" value="EmailJoiner"/>
 <!--
 		3. If an asset's class defines a container relationship, then:
-->
 <!--
 			a. List the container asset in the same import doc (preferably above, by convention).
-->
 <!--  			b. State the reference to the container asset.   -->
 <!--
 		XML Attributes that describe a reference to the container asset:
				name:     REST name of the container reference, in the form: '$' <container-class-localId>
				assetIDs: Exactly one ID of the asset that contains this asset, within this doc.
			Example:
			This asset's class defines a containment relationship: containerClassRefs="Project".
			Therefore, this asset must point to its container asset:
-->
<reference name="$Project" assetIDs="a1"/>
</asset>
 <!--  ************************  -->
 <!--
 More assets of bundle-defined types, such as: internal job structures (operators, variables, ...) ...
-->
 <!--  	Examples:  -->
 <!--
 	Stage that reads from a DB table, with a data field:
-->
<asset class="$DataMass-Stage_File" repr="NameExtractorFromDB" ID="a3">
<attribute name="name" value="NameExtractorFromDB"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="fullname" ID="a4">
<attribute name="name" value="fullname"/>
<reference name="$Stage" assetIDs="a3"/>
</asset>
 <!--
 	Stage that reads from a DB table using a data connection, with another data field:
-->
<asset class="$DataMass-Stage_File" repr="EmailExtractorFromDB" ID="a5">
<attribute name="name" value="EmailExtractorFromDB"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="email" ID="a6">
<attribute name="name" value="email"/>
<reference name="$Stage" assetIDs="a5"/>
</asset>
 <!--
 	Stage that joins the name data with the email data, with the result field:
-->
<asset class="$DataMass-Stage_Transformer" repr="Joiner" ID="a7">
<attribute name="name" value="Joiner"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="niceEmail" ID="a8">
<attribute name="name" value="niceEmail"/>
<reference name="$Stage" assetIDs="a7"/>
</asset>
 <!--
 	Stage that writes to a data file, with a data field:
-->
<asset class="$DataMass-Stage_File" repr="WriterToFile" ID="a9">
<attribute name="name" value="WriterToFile"/>
<reference name="$Job" assetIDs="a2"/>
</asset>
<asset class="$DataMass-DataField" repr="niceEmail" ID="a10">
<attribute name="name" value="niceEmail"/>
<reference name="$Stage" assetIDs="a9"/>
</asset>
 <!--  ************************  -->
 <!--
 	Optionally, assets whose classes are not bundle-defined.
-->
 <!--
 	They are also identified by their REST class names, names, and containers.
-->
 <!--
 	Some types require additional attributes. Example: data files also require the path attribute value for their logical identity.
-->
 <!--
 	In describing the following data sources, only the these XML attributes need to be adjusted per asset (everything else should be copied as is):
-->
 <!--
 		repr: 		Representation, the asset name. Must be equal to the value of the 'name' attribute.
-->
 <!--
 		ID: 		Merely *doc-internally* unique asset id (XML ID/IDREF mechanism). No need to be *globally* unique. No need to be the same in *other* import docs.
-->
 <!--
 					Must start with a letter and continue with letters or digits. Used for relating between assets within a given import document.
-->
 <!--
 		value: 		In <attribute name="name" value="<THE ASSET NAME>"/> - The asset name, part of the asset's logical identity.
-->
 <!--
 		assetIDs:	In <reference name="..." assetIDs="<ID OF CONTAINER ASSET>" - Container asset ID value.
-->
 <!--
 	Exceptions will be pointed out: data connection, data file.
-->
 <!--  ************************  -->
 <!--
 	"Host" asset, used in the example as the container for the following data connection, data base, and data file. They could of course all use different hosts, in real life.
-->
<asset class="host" repr="ROOK" ID="a100">
<attribute name="name" value="ROOK"/>
</asset>
 <!--  ************************  -->
 <!--
 	DB table/column hierarchy when identified by a DBs canonical representation (host-DB):
-->
 <!--  	*** Database ***  -->
<asset class="database" repr="CRM" ID="a200">
<attribute name="name" value="CRM"/>
<reference name="host" assetIDs="a100"/>
</asset>
 <!--  	*** Database schema ***  -->
<asset class="database_schema" repr="SOUTH" ID="a201" matchByName="true">
<attribute name="name" value="SOUTH"/>
<reference name="database" assetIDs="a200"/>
</asset>
 <!--  	*** Database table ***  -->
<asset class="database_table" repr="CLIENTS" ID="a202" matchByName="true">
<attribute name="name" value="CLIENTS"/>
<reference name="database_schema" assetIDs="a201"/>
</asset>
 <!--  	*** Database column ***  -->
<asset class="database_column" repr="FULLNAME" ID="a203" matchByName="true">
<attribute name="name" value="FULLNAME"/>
<reference name="database_table_or_view" assetIDs="a202"/>
</asset>
 <!--  ************************  -->
 <!--
 	DB table/column hierarchy when identified by a data connection. (note the additional 'imported_from' attribute):
-->
 <!--
 	Note: 1. Additional 'imported_from' attribute, must provide value.
			  2. Additional attribute 'virtualOnly="true"'. Just copy as is.
-->
 <!--
 		In order for data lineage to match up with the real, imported DB assets (tables, columns):
-->
 <!--
 		1. Create a mappable data connection using the IGC REST API. Either automatically, or manually using the IGC REST explorer at:
-->
 <!--
 		   		https://<host>:<port>/ibm/iis/igc-rest-explorer/#!/assets/createDataConnection
-->
 <!--
 		   Sample json payload, to match the sample data_connection asset below:
					{
					  "host" : "ROOK",
					  "connstr" : "xyzDriver:CRM-system",
					  "type" : "DB2"
					}
			2. Using IGC admin GUI, map this new mappable data connection to the actual, imported DB.
				Directions for this are on KC (IBM's Knowledge Center), here:
					https://www-01.ibm.com/support/knowledgecenter/SSZJPZ_11.3.0/com.ibm.swg.im.iis.mdwb.doc/topics/t_data_connection_mapping.html
			Note: Do not confuse these mappable data connections with the data connections on a database's details page.
				  The latter are for documentation purposes only, and have no impact on data lineage.

-->
 <!--  	*** Data connection ***  -->
<asset class="data_connection" repr="xyzDriver:CRM-system" ID="a300" virtualOnly="true">
<attribute name="name" value="xyzDriver:CRM-system"/>
 <!--         Set also the following XML attribute:  -->
 <!--
         	value: DB server type. Part of the data connection's logical identity.
-->
 <!--
         		   Prevents identity clashes between data connections of different types that happen to have the same connection string, on a given host.
-->
<attribute name="imported_from" value="DB2" tag="true"/>
<reference name="host" assetIDs="a100"/>
</asset>
 <!--  	*** Database schema ***  -->
<asset class="database_schema" repr="SSW" ID="a301" matchByName="true" virtualOnly="true">
<attribute name="name" value="SSW"/>
<reference name="database" assetIDs="a300"/>
</asset>
 <!--  	*** Database table ***  -->
<asset class="database_table" repr="EMAILS" ID="a302" matchByName="true" virtualOnly="true">
<attribute name="name" value="EMAILS"/>
<reference name="database_schema" assetIDs="a301"/>
</asset>
 <!--  	*** Database column ***  -->
<asset class="database_column" repr="EMAIL" ID="a303" matchByName="true" virtualOnly="true">
<attribute name="name" value="EMAIL"/>
<reference name="database_table_or_view" assetIDs="a302"/>
</asset>
 <!--  ************************  -->
 <!--   	Data file, identified by name, path, and host.  -->
 <!--  	*** Data file ***  -->
<asset class="data_file" repr="NiceEmails.txt" ID="a400">
<attribute name="name" value="NiceEmails.txt"/>
 <!--         Set also the following XML attribute:  -->
 <!--
         	value: File path. Part of the file's logical identity.
-->
<attribute name="path" tag="true" value="/people"/>
<reference name="parent_folder_or_host" assetIDs="a100"/>
</asset>
 <!--  	*** Data file record ***  -->
 <!--
 	Note: Data file records have been modeled in IGC core in order to express things like multi-spreadsheet workbook files.
-->
 <!--
 		  In those cases, there will be one data file record per spreadsheet.
-->
 <!--
 		  In most cases, however, we just have to create one record per file, to satisfy the model.
-->
 <!--
 		  By convention, the record name should be the file name, without the suffix.
-->
 <!--
 	As seen below, we map level-2 assets to data file *records*, not to data file.
-->
<asset class="data_file_record" repr="NiceEmails" ID="a401">
<attribute name="name" value="NiceEmails"/>
<reference name="data_file" assetIDs="a400"/>
</asset>
 <!--  	*** Data file field ***  -->
<asset class="data_file_field" repr="email" ID="a402">
<attribute name="name" value="email"/>
<reference name="data_file_record" assetIDs="a401"/>
</asset>
</assets>
 <!--  ************************  -->
 <!--  	Data flow   -->
 <!--  DEFINITIONS  -->
 <!--  	FLOW   -->
 <!--
 		Simple mapping between assets, source to target. Can be one-or-more sources to one-or-more targets.
-->
 <!--  	FLOW UNIT  -->
 <!--
 		Group of flows associated with an asset. An asset can only have up to one flow unit, and a flow unit refers to exactly one asset.
-->
 <!--
 		This asset can be thought of as the actor or data mover that is responsible for the flows in its flow unit.
-->
 <!--  		Examples: Job (design), Job run, Stored procedure.  -->
 <!--
 		This asset must have been imported before uploading its flow unit. Otherwise, IGC will not accept the flow unit with its flows.
-->
 <!--
 		Uploading flows for a flow unit will first of all delete any previous flows for that flow unit, and any flows within.
-->
 <!--
 		Therefore, 'historical' data flows can be achieved by adding more assets, such as runs, executions, ...
-->
 <!--
 		Deleting an asset will delete its flow unit (if exists), and any flows within.
-->
 <!--  	SUB FLOW  -->
 <!--
 		Flows can be grouped and nested within sub flows. This is useful when many (but not all) flows in a flow unit share the same attributes (flowType, reuseType).
-->
<flowUnits>
 <!--  	One or more flow units per document...  -->
<flowUnit assetID="a2">
 <!--
         Sub flows are used for grouping flows. Setting attributes such as flowType and reuseType are applied to all flows within a subFlow.
-->
 <!--  		XML attributes that describe subFlows or flows:  -->
 <!--
 			flowType:  One of DESIGN, OPERATIONAL, SYSTEM, USER, OTHER_IMPACT. See 'FlowTypeID', in flow_v1_0.xsd.
-->
 <!--
 					   Purpose: IGC data lineage reports can be filtered by flow type. Reports also indicate the flow type of a link, when hovering over it.
-->
 <!--
  			reuseType: Only needed when asset structures can be re-used in multiple flow units (runs).
-->
 <!--
  					   In that case, must be one of ('ENTRY', 'INNER', 'EXIT'). Otherwise, the run context will be lost, and lineage will fan out in wrong directions.
-->
 <!--
  				 	   Note: Some tool integrations choose not to reuse asset structures. Instead, they create them separately for each run.
-->
 <!--
         	comment:   You can have your code add comments per flowUnit, subFlow, and flow. This can help trace and debug code. IGC ignores these comments.
-->
 <!--
         			   Note: The reason to use these comments instead of XML comments is that XML comments are not available in the parsed document.
-->
 <!--
 		******************************************************
-->
 <!--
 		Simple version, for starters: No structure sharing. No optimization:
-->
 <!--  		*********************  -->
 <!--  		All inner flows  -->
 <!--
         flowType="SYSTEM", meaning these flows are hard-wired, they happen in all job runs.
-->
<subFlows flowType="SYSTEM" comment="All inner job flows">
<flow sourceIDs="a4 a6" targetIDs="a8" comment="stage fields 'NameExtractorFromDB.fullname', 'EmailExtractorFromDB.email' => stage field 'Joiner.niceEmail'"/>
<flow sourceIDs="a8" targetIDs="a10" comment="stage field 'Joiner.'niceEmail' => stage field 'WriterToFile.niceEmail' "/>
 <!--  	        More flows...  -->
</subFlows>
 <!--  		*********************  -->
 <!--  		All in/out flows  -->
 <!--
         flowType="DESIGN", meaning these flows are predicted based on default value parameterization - 'what would happen if run with default params'.
-->
<subFlows flowType="DESIGN" comment="All in/out flows">
<flow sourceIDs="a203" targetIDs="a4" comment="db column 'CLIENTS.FULLNAME' => stage field 'NameExtractorFromDB.fullname'"/>
<flow sourceIDs="a303" targetIDs="a6" comment="db column 'EMAILS.EMAIL' => stage field 'NameExtractorFromDB.email'"/>
<flow sourceIDs="a10" targetIDs="a402" comment="stage field 'WriterToFile.niceEmail' => file field 'NiceEmails.email' "/>
 <!--  	        More flows...  -->
</subFlows>
 <!--
 		******************************************************
-->
 <!--
 		Advanced version: Enabling structure sharing. Optimization:
-->
 <!--  		*********************  -->
 <!--  		All input flows  -->
<subFlows flowType="DESIGN" comment="All reading from incoming data sources">
 <!--          	Optimization example:  -->
 <!--
         		1. Mapping flows on the table level (2), in addition to column level (1).
-->
 <!--
         		2. Stating 'restatedAtContainer="true"' in the column-level sub flows.
-->
 <!--
         	Reason: Since we declared that any column-level flows are also reflected in table-level flows,
-->
 <!--
         			Lineage report navigation started on the table level will know not to navigate via all the columns flows.
-->
<flow sourceIDs="a202" targetIDs="a3" comment="db table 'CLIENTS' => stage 'NameExtractorFromDB'"/>
<flow sourceIDs="a302" targetIDs="a5" comment="db table 'EMAILS' => stage 'EmailExtractorFromDB'"/>
<subFlows restatedAtContainer="true">
<flow sourceIDs="a203" targetIDs="a4" comment="db column 'CLIENTS.FULLNAME' => stage field 'NameExtractorFromDB.fullname'"/>
<flow sourceIDs="a303" targetIDs="a6" comment="db column 'EMAILS.EMAIL' => stage field 'NameExtractorFromDB.email'"/>
</subFlows>
</subFlows>
 <!--  		*********************  -->
 <!--  		All inner flows  -->
 <!--
         flowType="SYSTEM", meaning these flows are hard-wired, they happen in all job runs.
-->
 <!--
         reuseType="INSIDE", such that data flow will be reported in the context of this flow unit, to match ENTRY and EXIT
-->
<subFlows flowType="SYSTEM" comment="All inner job flows">
 <!--
         	Note: The flow [a3 a5]=>a7 can alternatively be expressed as two separate flows: a3=>a7 and a5=>a7.
					  IGC does not care, and there is no difference in performance or reports.
-->
<flow sourceIDs="a3 a5" targetIDs="a7" comment="stages 'NameExtractorFromDB' and 'EmailExtractorFromDB' => stage 'Joiner'"/>
<flow sourceIDs="a7" targetIDs="a9" comment="stage 'Joiner' => stage 'WriterToFile'"/>
<subFlows restatedAtContainer="true">
<flow sourceIDs="a4 a6" targetIDs="a8" comment="stage fields 'NameExtractorFromDB.fullname', 'EmailExtractorFromDB.email' => stage field 'Joiner.'niceEmail'"/>
<flow sourceIDs="a8" targetIDs="a10" comment="stage field 'Joiner.'niceEmail' => stage field 'WriterToFile.niceEmail' "/>
</subFlows>
</subFlows>
 <!--  		*********************  -->
 <!--  		All output flows  -->
 <!--
         flowType="DESIGN", meaning these flows are predicted based on default value parameterization - 'what would happen if run with default params'.
-->
 <!--
 			For some tools, such default parameterization may not exist. There, DESIGN flows may not be applicable, and only OPERATIONAL flows, held by "Run" assets, be uploaded.
-->
 <!--
         Stating EXIT, such that data flow will be reported in the context of this flow unit, to match ENTRY (above)
-->
<subFlows flowType="DESIGN" comment="All writing to target data sources.">
<flow sourceIDs="a9" targetIDs="a401" comment="stage 'WriterToFile' => file record 'NiceEmails'"/>
<subFlows restatedAtContainer="true">
<flow sourceIDs="a10" targetIDs="a402" comment="stage field 'WriterToFile.niceEmail' => file field 'NiceEmails.email' "/>
</subFlows>
</subFlows>
</flowUnit>
</flowUnits>
</doc>
